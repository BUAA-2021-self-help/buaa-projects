# Chapter05: The Transport Layer

> 20%

## Key Points

- TCP协议的**特点**、报文段结构、**可靠传输**
- TCP的**三次握手**和**四次挥手**
- TCP的**拥塞控制**过程
- UDP的特点和传输方式
- 端口和套接字的基本概念

## Basics

### 进程之间的通信

> page 203

- 网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。
- TCP(面向连接) & UDP(无连接)
- 运输层向高层用户屏蔽了下面网络核心的细节，它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。

### 端口&套接字

> page 206

- 服务器端使用的端口号
  - 熟知端口号
  - 登记端口号
- 客户端使用的端口号
  - 仅在客户进程运行时才动态选择，又称“短暂端口号”

> page 212

套接字socket=(IP地址:端口号)

每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：

TCP连接::={socket1,socket2}={(IP1,port1),(IP2,port2)}

(同一个IP地址可以有多个不同的TCP连接，而同一个端口号也可一尝尝鲜在多个不同的TCP连接中。)

## UDP

### 特点

- 无连接的，即发送数据之前不需要建立连接
- 尽最大努力交付
- 面向报文（对应用层交下来的报文，保留这些报文的边界，不拆分或合并）
- 没有拥塞控制
- 支持一对一、一对多、多对一和多对多的交互通信
- 首部开销小，仅8字节

### 首部格式

- 源端口
- 目的端口
- 长度（最小是8，仅首部）
- 检验和

在校验时，引入“伪首部”（包含源IP地址、目的IP地址、UDP长度）

## TCP

### 特点

> page 210

- 面向连接的运输层协议
- 每一条TCP连接只能有两个端点
  - 点对点，一对一
- TCP提供可靠交付的服务
  - 无差错、不丢失、不重复、按序到达
- 全双工通信
  - 连接的两端都设有发送缓存和接受缓存
- 面向字节流

### 报文段结构

> page 217

虽然面向字节流，但传送的数据单元却是报文段。

分为首部（前20个字节是固定的首部）、数据两部分，放入IP数据报中的数据部分。

- 源端口&目的端口
  - 各占2字节，TCP分用和UDP分用相似，通过端口实现
- 序号
  - 占4字节，范围：[0,2^32-1]，需用mod 2^32运算
  - 表示本报文段所发送的数据的第一个字节的序号
- 确认号
  - 4字节
  - 期望收到对方下一个报文段的第一个数据字节的序号
  - 确认号=N，表明到序号N-1为止的所有数据都已正确收到
- 数据偏移
  - 占4位
  - 报文段的数据起始处距离TCP报文段的起始处有多远
  - 以4字节为单位——数据偏移的最大值为60字节（TCP首部的最大长度）
- 保留
  - 占6位
- 紧急URG
  - 高优先级，插入到本报文段数据的最前面
- 确认ACK
  - ACK=1确认号字段才有效
- 推送PSH
  - 尽快交付接收应用进程，不再等待到整个缓存都填满了再向上交付
- 复位RST
  - 释放连接，重新建立运输连接
- 同步SYN
  - 连接建立时用来同步序号
- 终止FIN
  - 用来释放一个连接
- 窗口
  - 占2字节，[0,2^16-1]
  - 指发送本报文段一方的接受窗口
  - 从本报文段首部中的确认号算起，接受方目前允许对方发送的数据量（字节单位）
  - 窗口值作为接收方让发送方设置其发送窗口的依据
- 检验和
  - 和UDP类似，也要加12字节的伪首部
- 紧急指针
  - 占2字节
  - 仅在URG=1时有意义，指出本报文段中的紧急数据的字节数
- 选项
  - 无选项时，TCP首部长度为20字节
  - 最大报文段长度MSS：每一个TCP报文段中的数据字段的最大长度
  - 窗口扩大选项
  - 时间戳选项
  - 选择确认SACK

## 可靠传输

### 停止等待协议

> page 213

设置超时计时器，超时重传，需要确认。

通过确认和重传机制，在不可靠的传输网络上实现可靠的通信。

自动重传请求ARQ

### 连续ARQ协议

> page 216, 221

滑动窗口协议

累积确认，对按序到达的最后一个分组发送确认，表示：到这个分组位置的所有分组都已正确收到了。

> page 224

发送缓存用来暂时存放：

- 发送应用程序传送给发送方TCP准备发送的数据
- TCP已发送出但尚未收到确认的数据

发送窗口通常只是发送缓存的一部分。

接受缓存用来暂时存放：

- 按序到达的、但尚未被接收应用程序读取的数据
- 未按序到达的数据

- 发送窗口和接受窗口不总是一样大
- 不按序到达的数据先临时存放在接受窗口，等缺少的字节收到后，再按序交付上层的应用进程
- TCP要求接收方有累积确认的功能。
- TCP全双工通信

#### 超时重传时间的选择

> page 225

- $RTT_S$：平滑的往返时间
- $RTO$：超时重传时间
- $RTT_D$：RTT的偏差的加权平均值

$$新的RTT_s=(1-\alpha)\times(旧的RTT_S)+\alpha\times(新的RTT_S样本)$$

推荐$\alpha$是1/8

$$RTO=RTT_S+4\times RTT_D$$

$$RTT_D=(1-\beta)\times(旧的RTT_D)+\beta\times\lvert RTT_S-新的RTT_S样本\rvert$$

- Karn算法

> page 226

在计算加权平均$RTT_S$时，只要报文段重传了，就不采用其往返时间样本。这样得出的加权平均$RTT_S$和$RTO$就较准确。

#### 选择确认SACK

> page 226

Selective ACK

- 首部选项的长度最多40个字节
- 一个边界用掉4字节（序号有32位）
- 一个字节块要指明两个边界
- 额外需要两个字节：指明是SACK选项的，指明该选项要占用多少个字节

因此最多指明4个字节块的边界信息(4\*2\*4+2=34，再来一个字节块就要+8，会超40)

## 流量控制

> page 227

让发送方的发送速率不要太快，要让接收方来得及接收。

问题：非零窗口的报文段在传送过程中丢失而产生的这样一个情况——A一直等待收到B发送的非零窗口的通知，而B也一直等待A发送的数据。互相等待（死锁）

解决：为每一个连接设立持续计时器。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段，而对方就在确认这个探测报文段时给出当前的窗口值。

## 拥塞控制

> page 229

若网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。该情况即拥塞。

$$\sum 对资源的需求 \gt 可用资源$$

> page 230

流量控制 vs 拥塞控制

- 拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。是网络能够承受现有的网络负荷。是全局性的过程，牵涉到所有的主机、所有的路由器等
- 流量控制：往往是点对点通信量的控制，端到端问题

开环控制（设计时事先全考虑） & 闭环控制（反馈环路，动态）

### 方法

> page 232

- 慢开始
- 拥塞避免
- 快重传
- 快恢复

流程图 page 236

- 超时
  - ssthresh=cwnd/2
  - cwnd=1
- 3个重复的ACK
  - ssthresh=cwnd/2
  - cwnd=ssthresh

考虑接收方窗口值rwnd

$$发送方窗口的上限值=\min[rwnd, cwnd]$$

## 运输连接管理

### 连接建立：三次握手

> page 238

### 连接释放：四次挥手

> page 240
